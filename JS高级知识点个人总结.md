<!DOCTYPE html>

    <script>
        //JavaScript是什么?
        //是一种编程语言,
        //是一门脚本语言:不需要编译,直接就执行,cmd,sql
        //是一门弱类型语言:声明所有类型的变量都用var
        //是一门动态类型语言:变量(对象)在执行的时候,才能确定这个变量的类型
        //是一门解释性的语言:需要解释器;预解析,然后执行每行代码
        //是一门基于对象的语言:js中的对象都是已经存在的了(内置对象),直接使用对象,可以模拟面向对象
        
        //变量声明了,没有赋值,结果是undefined
        // 函数没有明确的返回值,结果是undefined

        //普通变量不能直接调用属性和方法
        //对象才可以直接调用属性和方法

        //值类型之间传递的是值
        //引用类型之间传递的是地址引用

        //面向过程和面向对象都是编程思想. 
        //面向过程:凡事都是亲力亲为,每一步都要清楚,注重的是过程
        //面向对象:找对对象,注重的是结果,所有的事情都是通过对象来进行操作

        //面向对象特性:封装,继承,多态
        //封装:把一系列的代码封装成函数,好多的函数,封装在对象中
        //继承:是类与类之间的关系,js中没有类的这个概念,通过原型模拟继承
        //多态:同一个行为针对不同的对象,产生不同的结果(模拟多态,但是几乎不用)

        //对象:特指的某个事物(看得见,摸得到,特指的某个东西),具有属性和方法,世间万物皆对象

        // 构造函数中都有一个属性:prototype,叫原型,是程序员用的
        // 实例对象中都有一个属性:__proto__,叫原型,是浏览器提供的的,不标准
        // 无论是prototype还是__proto__都可以看成是一个对象(原型对象)
        // 构造函数中的原型(prototype)和实例对象中的原型(__proto__)都是属性，同时也都是对象
        // 构造函数中的prototype和实例对象中的__proto__指向相同,都指向构造函数的prototype原型对象

        //原型的作用之一:数据共享---节省空间
        //原型的作用之二:继承
        //构造函数中的原型:prototype,程序员使用的
        //实例对象中的原型:__proto__,浏览器使用的,不标准的,指向的位置就是构造函数的prototype指向的地方,prototype中的数据就可以被实例对象访问和调用
        //如果希望数据能够共享,应该把数据(属性和方法)放在原型对象(prototype)中
        //如果数据不需要共享,那么就放在构造函数中定义

        //构造函数和实例对象之间的关系,叫原型链,原型链是通过原型(__proto__)来联系的

        //对象.hasOwnProperty(属性名或者方法名) 判断属性或者方法是不是自身定义的属性或者方法  返回boolean值 如果是继承的或者没有就返回false

        //delete  可以删除对象属性或属性

        //构造函数中的this和原型对象方法中的this指向相同,都是实例对象

        //把局部变量变成全局变量
        //方法一
        // (function () {
        //   var num = 10;
        //   window.num = num;//把num这个局部变量暴露给window顶级对象
        // })
        //方法二(一般使用这个方式,在代码压缩时不会产生问题)
        //    (function (win) {
        //      var num=10;//局部变量
        //      //把num这个局部变量暴露给window顶级对象
        //      win.num=num;
        //    })(window);//传入window对象
        //    console.log(num);

        //自定义构造函数创建新实例对象:4件事
        //也就是 new 关键字的作用
        //1.在内存中申请一块空闲的空间,存储新创建的实例对象
        //2.改变this的指向;使其指向当前创建的实例对象
        //3.执行构造函数中的代码
        //4.把创建后的实例对象返回

        //通过原型为内置对象添加原型的属性或者方法(不建议这样做;程序员潜规则)----->原因:
        //系统的内置对象的属性和方法可能不满足现在需求,所以,可以通过原型的方式加入属性或者方法,为了方便开发
        //为内置对象的原型中添加属性和方法,那么这个内置对象的实例对象就可以直接使用了

        //内置对象的 constructor 属性为只读属性
        //为了快速添加可继承的属性和方法 可以使用 构造函数.prototype = {属性: 属性值,方法..};但是这样会产生一个问题,原型对象的 constructor 属性丢失(造成实例对象的constructor指向不正确),为了解决这个问题,所以要手动添加 constructor 属性
        //例 Person.prototype = { constructor: Person, name: 'gt', eat:function(){} }

        //如果实例对象中没有这个属性,但是,原型对象中有这个属性,那么就会使用原型对象中的该属性

        //使用的方式是需要的搜索,先在实例对象中找这个属性,有,则使用,没有则去原型对象中找,找到了就使用,没找到再继续向上寻找直到null,返回undefined
        //为什么这个属性的结果是undefined?因为js是一门动态类型的语言,该对象没有这个属性,点了,那么就有这个属性了(相当于初始化),没有赋值,所以结果是undefined

        //实例对象的__proto__指向的是自己的构造函数的prototype
        //如果构造函数的prototype指向发生改变,那么实例对象的__proto__指向也改变(Person.prototype指向了什么地方,那么实例对象的__proto__也会指向那个地方)
        //切记:如果构造函数的原型指向改变了,再向原型中添加方法,那么这个方法被添加到了所改变指向的位置了

        //继承:在纯面向对象语言中,继承指的是类(class)与类(class)之间的关系,为了也是数据共享的问题,但是js是一门基于对象的语言,没有类的概念,但是,js可以模拟面向对象,可以把js中的构造函数当成是面向对象语言中的类来看待(可以使用构造函数来代替类)

        //js中的构造函数可以看成是面向对象语言中的类(class)

        //在某个构造函数中使用:构造函数.call()形式,借用构造函数
        //缺陷:这种方式不能直接调用继承的方法,因为方法没有继承,但是属性继承了

        //通过改变原型指向,指向一个新的实例对象的方式实现继承
        //Student.prototype=new Person();
        //借用构造函数继承:
        //构造函数.call(this,属性1,属性2,属性3...);只能使用属性,不能继承方法
        //组合继承:借用构造函数+改变原型指向，既能继承属性.也能继承方法
        //拷贝继承:把原来对象中的属性和方法直接复制一份放在新的对象中

        //函数的角色
        //函数声明:function f1(){} --命名函数, 匿名函数function(){};
        //函数表达式:var ff=function f2(){};  var ff=function(){};
        //var fn = new Function("参数1","参数2"....,"代码");
        //任何函数都应该是Function的一个实例对象

        //函数声明---注意:IE8中的函数声明如果是在if-else语句中并且if语句中的判断语句是正确的,那么执行的是else中的代码  其他浏览器使用的是if语句中的代码
        //型如
        //        if(true){
        //            function ff() {
        //                console.log("1");
        //            }
        //        }else{
        //            function ff() {
        //                console.log("2");
        //            }
        //        }
        //以后使用函数表达式的方式最好不要把函数的声明写在if-else的语句中

        //在不改变this的指向前提下
        //普通模式下调用函数,函数中的this是window
        //如果是new的方式,那么函数中的this就是当前构造函数的实例对象
        //对象中的方法,里面的this是当前对象
        //构造函数中的方法.里面的this是当前构造函数的实例对象
        //定时器中的this就是window

        //如果是严格模式下调用函数,那么this就应该指向undefined
        //"use strict";//严格模式  在JS文件前加入此句就为严格模式

        //对象中有__proto__ 是原型
        //函数(构造函数是其中一种)中有prototype 是原型
        //构造函数是函数,函数都是Function的实例对象,函数都是对象,函数中有两个原型: __proto__ ; prototype
        //对象不一定是函数,例如Math(其余大部分都是)

        //数组中什么类型的数据都可以存放

        //函数也是对象,对象可以添加属性,可以添加方法

        //这个两个方法都是Function原型中的,此时和普通方式调用没有区别
        //f1.apply();//相当于是f1函数自己调用了
        //f1.call();//相当于f1函数自己调用了
        //f1.apply(null);//相当于是f1函数自己调用了
        //f1.call(null);//相当于f1函数自己调用了

        //区别:参数apply的参数是以数组/arguments的方式传入---第二个参数
        //call的参数是以一个一个的参数传入的---第二个和第三个...多个参数
        //apply和call都可以接收返回值
        //apply和call中的第一个参数如果不传,或者传的是null,函数中的this是window
        //apply和call中的this默认是window,如果第一个参数传入的是A这个对象,那么函数中的this就会指向现在的A,this指向可以改变

        //apply或者是call前面要想调用:方法名----函数名.apply或者函数名.call
        //例子==========
        //    var result1=Person.apply(null,[参数1,参数2]);
        //    var result2=Person.call(this,参数1,参数2);

        //bind也是一个方法,在ECMAScript5中,新的
        //函数名.bind()方法,相当于是复制了这个函数,返回值就是复制后的一个函数
        //        无论是apply还是call或者是bind中第一个参数不传,或者是传的是null,那么函数中的this都是window
        // bind方法的参数传入方式和call是一样的
        // 函数名.bind(对象A,参数1,参数2,...);就相当于是把函数复制了一份,相当于复制到了对象A中了,------>改变了函数中的this指向
        //改变this指向的方法:apply和call和bind(bind不调用,是复制了一份)
        //想要改变this指向就可以使用这三个方法中的任意一个,比较推荐的是apply和call
        // 想要改变this指向,并且想要复制一个函数或者方法,就用bind

        //函数中的几个常见的成员
        //属性和方法都是一个对象中的成员
        //函数中的name属性是函数的名字 (不可改变)
        //arguments属性,是传入的实参形成的一个伪数组.arguments.length是实参的个数
        //length属性.函数的形参的个数
        //caller属性:是调用者,函数1如果在函数2中被调用,那么函数1中的caller就是函数2  如果没有调用者 则是null
        
        //arguments的属性
        //length: 函数实参的个数
        //callee: 当前函数自身 

        //函数可以作为参数使用,命名函数或者是匿名函数都可以,注意:命名函数只传入函数的名字

        //Object.prototype.toString.call({}) 可以获取当前的这个括号中的东西是什么类型的  "[object 某个数据类型首字母大写的]"
        //例子===============================
        //    var arr=[10,20,30];
        //    var obj={};
        //    console.log(Object.prototype.toString.call(Math)=="[object Math]");

        //闭包:函数A中有一个函数B,函数B中可以访问函数A中的变量或者数据,此时形成闭包
        //闭包的模式:函数模式(里面的返回作为返回值),对象模式(里面的对象作为返回值)
        //闭包的作用:缓存数据-延长数据链-延迟数据释放-是优点也是缺点
        //函数模式的闭包
        //        function f1() {
        //            var num = 10;
        //            return function () {
        //                console.log(num);
        //            }
        //        }
        //        var ff=f1();
        //        ff();
        //对象模式的闭包
        //        function f3() {
        //            return {
        //                age:100,
        //                getAge:function () {
        //                    console.log(this.age);
        //                }
        //            }
        //        }

        //闭包的作用缓存数据:只要是想把数据保存起来,就把这个数据放在闭包中(就是在外层函数和里层函数的中间)
        //正因为闭包的出现了缓存数据,那么函数中的变量就没有得到及时的释放.但是闭包的情况,该变量的值没有释放,延长作用域了.

        //沙箱:又名环境,黑盒,---在虚拟的世界中,模拟真实世界的场景,做实验,实验的结果和真实世界的结果一样,但是不会影响真实的世界;也就说有自己的独立作用域
        //沙箱可以解决命名冲突的问题(防止全局污染)

        //递归:在函数A中调用函数A自己,就是递归,但是递归必须要有结束的条件
        //递归--->如果没有结束的条件.就是一个死循环
        //!!!!!!递归:必须要有结束的条件!!!!!!

        //浅拷贝:就是把一个对象的属性和方法拷贝到另一个对象中,但是引用类型的数据会共享

        //深拷贝:把一个对象中的属性方法,依次的,一个一个的复制到另一个对象中,引用类型的数据不会共享,一般使用递归实现
        //JSON.parse(JSON.stringify())也可实现深拷贝, 前提是带拷贝的数据里面不能包含函数

        //正则表达式的作用：匹配字符串的
        //正则表达式:就是一个表达式,这个表达式中由一些特殊的符号组合而成,可以匹配一些字符串内容,这样表达式就是正则表达式,也叫规则表达式
        //这些符号在正则表达式中都可以叫元字符
        //由元字符组合而成的表达式叫正则表达式
        //正则表达式在其他的编程语言中也是一样的,是同一个技术,//
        //元字符(普通的元字符,限定符)

        //元字符: (标准模式!!只要含有!!!正则表达式匹配的内容就匹配成功)
        //1.
        // .  ---->可以匹配除了\n以外的任意的单个的字符   "89abc"
        //2.
        // [a-b]--->a到b(包含a,b)范围中的一个字符
        // [0-9] 表示的是0到9之间的任意的一个数字(包含0,也包含9) "hello98"
        // [3-9] 表示的是3到9之间的任意的一个数字 "我的电话398125"
        // [a-z]表示所有的小写的字母中的任意一个
        // [A-Z]表示的所有的大写字母中的任意一个
        // [a-zA-Z]表示的所有的大小写字母中的任意一个
        // [0-9a-zA-Z]表示的是所有的数字和字母中任意一个
        // [yY]--->就是一个字符 Y或者y  "fdYsfds"
        //特殊元字符放在[]中变为普通字符
        // [.]---->就是一个普通的 .
        //添加 - 普通字符时 将其放在最后
        //[._-]
        //3.
        // ()----优先级和分组   ([0-9]([a-z]))两组:从左向右依次的计算()个数
        //()(()(()))((())):----->8组
        //4.
        // | 或者  ([4-8]|[A-Z])  "12Eyui"
        //元字符中的限定符
        //5.
        // * 该符号前面的表达式出现了0次或多次 [0-9][a-z]*  "fdf32e2332"
        //6.
        // + 该符号前面的表达式出现了1次或多次 [0-9][a-z]+  "32738afdsf3233"
        //7.
        // ? 该符号前面的表达式出现了0次或1次  [1-5]?   "2ee3" (用于阻止贪婪模式)
        //8.
        //{min,max} 范围,a到b之间的限定范围次数
        //{0,} 该符号前面的表达式出现了0次到多次
        //{1,} 该符号前面的表达式出现了1次到多次
        //{0,1}该符号前面的表达式出现了0次或1次
        //{3} 该符号前面的表达式出现了3次    [0-9]{3}  "ddweew37689"
        //{5,100}该符号前面的表达式出现了5次到100次
        // \d   ---->所有的数字中的一个 和[0-9]是一样的
        // \D  ----->非数字
        // \s  ----->空白符号
        // \S  ----->非空白符号
        // \w  ----->非特殊符号 是有_
        // \W  ----->特殊符号 ,是没有_
        // ^  ----->1.以什么开头, ^[0-9]以数字开头  2.取非   [^0-9]  非数字
        // $  ----->以什么结尾    [0-9]$---->这个字符串应该是以数字结尾的才能和正则表达式匹配上
        //\b ----->单词的边界  "what are you no sha lei";

        //粗略匹配中文名 /^[\u4e00-\u9fa5]{2,6}$/  Unicode码

        //创建正则表达式的对象
        //1.通过构造函数创建对象
        //1.1 var reg=new RegExp(/正则表达式/,"g|i");
        //下面这种需要将常规的字符转义 [<>$&\]（在前面加反斜杠 \）
        //1.2 var reg=new RegExp("正则表达式","g|i");
        //2.通过字面量的方式来创建对象
        //var reg=/正则表达式/g|i;

        //正则对象 test方法 检测字符串是否匹配 返回boolean
        //正则表达式或者变量.test(string);

        //正则表达式不仅仅是匹配是否成功,也可以用来提取或者筛选相关的内容
        //字符串: match方法返回匹配成功的字符串组成的数组
        //str.match(/正则表达式/g|i)

        //如果正则表达式有小括号并且前面有匹配表达式,那么这个正则表达式就有分组了,想要那一组的东西,就可以直接使用RegExp.$所在组数
        //console.log(RegExp.$3);

        //g---->全局模式
        //i---->忽略大小写
        //m---->多行模式

        // 特殊字符串方法replace第一个参数可以是正则表达式/字符串
        //第二个参数可以是回调函数/字符串
        //第二个参数为回调函数时 回调函数的参数为前面匹配到的字符
        //例子  将字符串中的 <>&"字符转换成相应的字符实体
        //function escapeHtml(str) {
        //    str = str.replace(/[<>&"]/g,function (match) {
        //        switch(match){
        //            case "<": return "&lt;";
        //            case ">": return "&gt;";
        //            case "&": return "&amp;";
        //            case "\"": return "&quot;";
        //        }
        //    });
        //    return str;
        //}
        //console.log(escapeHtml("<>dudhfk\"ahs&asdasd"));

        //    var str="HhUYuy";
        //    str=str.replace(/[h]/gi,"P");//又是全局又是忽略大小写
        //    console.log(str);

        //匹配不到数值时为值为null

        //伪数组:假的数组,有length属性.但是不能使用数组中的方法
        //伪数组不能调用数组中的方法
        //数组是对象 对象不一定是数组
    </script>

